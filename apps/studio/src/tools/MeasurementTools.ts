import * as THREE from 'three';

export interface MeasurementPoint {
  id: string;
  position: THREE.Vector3;
  type: 'vertex' | 'edge' | 'face' | 'free';
  nodeId?: string;
  elementId?: string;
}

export interface Measurement {
  id: string;
  type: 'distance' | 'angle' | 'radius' | 'area' | 'volume';
  points: MeasurementPoint[];
  value: number;
  unit: string;
  label: string;
  visible: boolean;
  precision: number;
}

export interface DistanceMeasurement extends Measurement {
  type: 'distance';
  points: [MeasurementPoint, MeasurementPoint];
}

export interface AngleMeasurement extends Measurement {
  type: 'angle';
  points: [MeasurementPoint, MeasurementPoint, MeasurementPoint]; // vertex, point1, point2
}

export interface RadiusMeasurement extends Measurement {
  type: 'radius';
  points: [MeasurementPoint]; // center point
  radius: number;
}

export interface AreaMeasurement extends Measurement {
  type: 'area';
  points: MeasurementPoint[];
  area: number;
}

export interface VolumeMeasurement extends Measurement {
  type: 'volume';
  nodeId: string;
  volume: number;
}

export class MeasurementToolsManager {\n  private measurements: Map<string, Measurement> = new Map();\n  private scene: THREE.Scene;\n  private measurementGroup: THREE.Group;\n  private listeners: Set<(measurements: Measurement[]) => void> = new Set();\n  private activeTool: string | null = null;\n  private tempPoints: MeasurementPoint[] = [];\n  \n  constructor(scene: THREE.Scene) {\n    this.scene = scene;\n    this.measurementGroup = new THREE.Group();\n    this.measurementGroup.name = 'measurements';\n    this.scene.add(this.measurementGroup);\n  }\n  \n  /**\n   * Start a measurement tool\n   */\n  startTool(toolType: Measurement['type']): void {\n    this.activeTool = toolType;\n    this.tempPoints = [];\n    this.updateCursor(toolType);\n  }\n  \n  /**\n   * Cancel current measurement\n   */\n  cancelTool(): void {\n    this.activeTool = null;\n    this.tempPoints = [];\n    this.updateCursor('default');\n    this.clearTempVisuals();\n  }\n  \n  /**\n   * Add a point to the current measurement\n   */\n  addPoint(point: MeasurementPoint): boolean {\n    if (!this.activeTool) return false;\n    \n    this.tempPoints.push(point);\n    this.updateTempVisuals();\n    \n    // Check if we have enough points to complete the measurement\n    const requiredPoints = this.getRequiredPointCount(this.activeTool);\n    if (this.tempPoints.length >= requiredPoints) {\n      this.completeMeasurement();\n      return true;\n    }\n    \n    return false;\n  }\n  \n  /**\n   * Create distance measurement\n   */\n  createDistanceMeasurement(point1: MeasurementPoint, point2: MeasurementPoint): string {\n    const distance = point1.position.distanceTo(point2.position);\n    const id = this.generateId();\n    \n    const measurement: DistanceMeasurement = {\n      id,\n      type: 'distance',\n      points: [point1, point2],\n      value: distance,\n      unit: 'mm',\n      label: `${distance.toFixed(2)} mm`,\n      visible: true,\n      precision: 2,\n    };\n    \n    this.measurements.set(id, measurement);\n    this.createDistanceVisual(measurement);\n    this.notifyListeners();\n    \n    return id;\n  }\n  \n  /**\n   * Create angle measurement\n   */\n  createAngleMeasurement(vertex: MeasurementPoint, point1: MeasurementPoint, point2: MeasurementPoint): string {\n    const v1 = new THREE.Vector3().subVectors(point1.position, vertex.position).normalize();\n    const v2 = new THREE.Vector3().subVectors(point2.position, vertex.position).normalize();\n    const angle = Math.acos(THREE.MathUtils.clamp(v1.dot(v2), -1, 1));\n    const angleDegrees = THREE.MathUtils.radToDeg(angle);\n    \n    const id = this.generateId();\n    \n    const measurement: AngleMeasurement = {\n      id,\n      type: 'angle',\n      points: [vertex, point1, point2],\n      value: angleDegrees,\n      unit: '°',\n      label: `${angleDegrees.toFixed(1)}°`,\n      visible: true,\n      precision: 1,\n    };\n    \n    this.measurements.set(id, measurement);\n    this.createAngleVisual(measurement);\n    this.notifyListeners();\n    \n    return id;\n  }\n  \n  /**\n   * Create radius measurement\n   */\n  createRadiusMeasurement(center: MeasurementPoint, radius: number): string {\n    const id = this.generateId();\n    \n    const measurement: RadiusMeasurement = {\n      id,\n      type: 'radius',\n      points: [center],\n      value: radius,\n      unit: 'mm',\n      label: `R${radius.toFixed(2)} mm`,\n      visible: true,\n      precision: 2,\n      radius,\n    };\n    \n    this.measurements.set(id, measurement);\n    this.createRadiusVisual(measurement);\n    this.notifyListeners();\n    \n    return id;\n  }\n  \n  /**\n   * Remove a measurement\n   */\n  removeMeasurement(id: string): boolean {\n    const measurement = this.measurements.get(id);\n    if (!measurement) return false;\n    \n    this.measurements.delete(id);\n    this.removeVisual(id);\n    this.notifyListeners();\n    \n    return true;\n  }\n  \n  /**\n   * Clear all measurements\n   */\n  clearAll(): void {\n    this.measurements.clear();\n    this.measurementGroup.clear();\n    this.notifyListeners();\n  }\n  \n  /**\n   * Toggle measurement visibility\n   */\n  toggleVisibility(id: string): boolean {\n    const measurement = this.measurements.get(id);\n    if (!measurement) return false;\n    \n    measurement.visible = !measurement.visible;\n    this.updateVisualVisibility(id, measurement.visible);\n    this.notifyListeners();\n    \n    return true;\n  }\n  \n  /**\n   * Update measurement precision\n   */\n  updatePrecision(id: string, precision: number): boolean {\n    const measurement = this.measurements.get(id);\n    if (!measurement) return false;\n    \n    measurement.precision = precision;\n    measurement.label = this.formatMeasurementLabel(measurement);\n    this.updateVisualLabel(id, measurement.label);\n    this.notifyListeners();\n    \n    return true;\n  }\n  \n  /**\n   * Get all measurements\n   */\n  getMeasurements(): Measurement[] {\n    return Array.from(this.measurements.values());\n  }\n  \n  /**\n   * Get measurement by ID\n   */\n  getMeasurement(id: string): Measurement | undefined {\n    return this.measurements.get(id);\n  }\n  \n  /**\n   * Subscribe to measurement changes\n   */\n  subscribe(listener: (measurements: Measurement[]) => void): () => void {\n    this.listeners.add(listener);\n    return () => this.listeners.delete(listener);\n  }\n  \n  /**\n   * Export measurements to JSON\n   */\n  exportMeasurements(): any {\n    return {\n      measurements: this.getMeasurements().map(m => ({\n        id: m.id,\n        type: m.type,\n        value: m.value,\n        unit: m.unit,\n        label: m.label,\n        points: m.points.map(p => ({\n          id: p.id,\n          position: p.position.toArray(),\n          type: p.type,\n          nodeId: p.nodeId,\n          elementId: p.elementId,\n        })),\n      })),\n    };\n  }\n  \n  private completeMeasurement(): void {\n    if (!this.activeTool || this.tempPoints.length === 0) return;\n    \n    switch (this.activeTool) {\n      case 'distance':\n        if (this.tempPoints.length >= 2) {\n          this.createDistanceMeasurement(this.tempPoints[0], this.tempPoints[1]);\n        }\n        break;\n      case 'angle':\n        if (this.tempPoints.length >= 3) {\n          this.createAngleMeasurement(this.tempPoints[1], this.tempPoints[0], this.tempPoints[2]);\n        }\n        break;\n      case 'radius':\n        if (this.tempPoints.length >= 1) {\n          // For radius, we need additional logic to determine the radius\n          // This is simplified - in practice, you'd pick a circular edge or surface\n          this.createRadiusMeasurement(this.tempPoints[0], 10); // placeholder radius\n        }\n        break;\n    }\n    \n    this.cancelTool();\n  }\n  \n  private getRequiredPointCount(toolType: string): number {\n    switch (toolType) {\n      case 'distance': return 2;\n      case 'angle': return 3;\n      case 'radius': return 1;\n      case 'area': return 3; // minimum for triangle\n      default: return 1;\n    }\n  }\n  \n  private createDistanceVisual(measurement: DistanceMeasurement): void {\n    const group = new THREE.Group();\n    group.name = measurement.id;\n    \n    // Line between points\n    const geometry = new THREE.BufferGeometry().setFromPoints([\n      measurement.points[0].position,\n      measurement.points[1].position,\n    ]);\n    \n    const material = new THREE.LineBasicMaterial({ \n      color: 0x00ff00,\n      linewidth: 2,\n    });\n    \n    const line = new THREE.Line(geometry, material);\n    group.add(line);\n    \n    // Point markers\n    this.addPointMarkers(group, measurement.points);\n    \n    // Label\n    this.addLabel(group, measurement.label, this.getMidpoint(measurement.points));\n    \n    this.measurementGroup.add(group);\n  }\n  \n  private createAngleVisual(measurement: AngleMeasurement): void {\n    const group = new THREE.Group();\n    group.name = measurement.id;\n    \n    const [vertex, point1, point2] = measurement.points;\n    \n    // Lines from vertex to points\n    const geometry1 = new THREE.BufferGeometry().setFromPoints([vertex.position, point1.position]);\n    const geometry2 = new THREE.BufferGeometry().setFromPoints([vertex.position, point2.position]);\n    \n    const material = new THREE.LineBasicMaterial({ color: 0xff6600, linewidth: 2 });\n    \n    group.add(new THREE.Line(geometry1, material));\n    group.add(new THREE.Line(geometry2, material));\n    \n    // Arc showing angle\n    const v1 = new THREE.Vector3().subVectors(point1.position, vertex.position).normalize();\n    const v2 = new THREE.Vector3().subVectors(point2.position, vertex.position).normalize();\n    const angle = Math.acos(THREE.MathUtils.clamp(v1.dot(v2), -1, 1));\n    \n    const arcGeometry = new THREE.RingGeometry(0.8, 1.0, 0, angle);\n    const arcMaterial = new THREE.MeshBasicMaterial({ color: 0xff6600, transparent: true, opacity: 0.3 });\n    const arc = new THREE.Mesh(arcGeometry, arcMaterial);\n    \n    // Position and orient the arc\n    arc.position.copy(vertex.position);\n    arc.lookAt(vertex.position.clone().add(v1.clone().cross(v2)));\n    \n    group.add(arc);\n    \n    // Point markers\n    this.addPointMarkers(group, measurement.points);\n    \n    // Label\n    this.addLabel(group, measurement.label, vertex.position.clone().add(v1.clone().add(v2).normalize().multiplyScalar(1.5)));\n    \n    this.measurementGroup.add(group);\n  }\n  \n  private createRadiusVisual(measurement: RadiusMeasurement): void {\n    const group = new THREE.Group();\n    group.name = measurement.id;\n    \n    const center = measurement.points[0].position;\n    const radius = measurement.radius;\n    \n    // Circle outline\n    const circleGeometry = new THREE.RingGeometry(radius - 0.05, radius + 0.05, 32);\n    const circleMaterial = new THREE.MeshBasicMaterial({ color: 0x0066ff, transparent: true, opacity: 0.5 });\n    const circle = new THREE.Mesh(circleGeometry, circleMaterial);\n    circle.position.copy(center);\n    group.add(circle);\n    \n    // Radius line\n    const lineGeometry = new THREE.BufferGeometry().setFromPoints([\n      center,\n      center.clone().add(new THREE.Vector3(radius, 0, 0)),\n    ]);\n    const lineMaterial = new THREE.LineBasicMaterial({ color: 0x0066ff, linewidth: 2 });\n    const line = new THREE.Line(lineGeometry, lineMaterial);\n    group.add(line);\n    \n    // Center point\n    this.addPointMarkers(group, [measurement.points[0]]);\n    \n    // Label\n    this.addLabel(group, measurement.label, center.clone().add(new THREE.Vector3(radius / 2, 0, 0)));\n    \n    this.measurementGroup.add(group);\n  }\n  \n  private addPointMarkers(group: THREE.Group, points: MeasurementPoint[]): void {\n    const markerGeometry = new THREE.SphereGeometry(0.1, 8, 8);\n    const markerMaterial = new THREE.MeshBasicMaterial({ color: 0xffffff });\n    \n    for (const point of points) {\n      const marker = new THREE.Mesh(markerGeometry, markerMaterial);\n      marker.position.copy(point.position);\n      group.add(marker);\n    }\n  }\n  \n  private addLabel(group: THREE.Group, text: string, position: THREE.Vector3): void {\n    // In a real implementation, you'd use a text rendering library\n    // For now, we'll create a simple placeholder\n    const labelGeometry = new THREE.PlaneGeometry(1, 0.3);\n    const labelMaterial = new THREE.MeshBasicMaterial({ \n      color: 0x000000, \n      transparent: true, \n      opacity: 0.8 \n    });\n    \n    const label = new THREE.Mesh(labelGeometry, labelMaterial);\n    label.position.copy(position);\n    label.userData = { text };\n    \n    group.add(label);\n  }\n  \n  private getMidpoint(points: MeasurementPoint[]): THREE.Vector3 {\n    const midpoint = new THREE.Vector3();\n    for (const point of points) {\n      midpoint.add(point.position);\n    }\n    return midpoint.divideScalar(points.length);\n  }\n  \n  private removeVisual(id: string): void {\n    const visual = this.measurementGroup.getObjectByName(id);\n    if (visual) {\n      this.measurementGroup.remove(visual);\n    }\n  }\n  \n  private updateVisualVisibility(id: string, visible: boolean): void {\n    const visual = this.measurementGroup.getObjectByName(id);\n    if (visual) {\n      visual.visible = visible;\n    }\n  }\n  \n  private updateVisualLabel(id: string, label: string): void {\n    const visual = this.measurementGroup.getObjectByName(id);\n    if (visual) {\n      // Update label text - implementation depends on text rendering system\n      const labelMesh = visual.children.find(child => child.userData.text);\n      if (labelMesh) {\n        labelMesh.userData.text = label;\n      }\n    }\n  }\n  \n  private formatMeasurementLabel(measurement: Measurement): string {\n    const value = measurement.value.toFixed(measurement.precision);\n    switch (measurement.type) {\n      case 'distance':\n        return `${value} ${measurement.unit}`;\n      case 'angle':\n        return `${value}°`;\n      case 'radius':\n        return `R${value} ${measurement.unit}`;\n      case 'area':\n        return `${value} ${measurement.unit}²`;\n      case 'volume':\n        return `${value} ${measurement.unit}³`;\n      default:\n        return `${value} ${measurement.unit}`;\n    }\n  }\n  \n  private updateCursor(toolType: string): void {\n    // Update cursor based on active tool\n    document.body.style.cursor = toolType === 'default' ? 'default' : 'crosshair';\n  }\n  \n  private updateTempVisuals(): void {\n    // Show temporary visual feedback while building measurement\n    // Implementation depends on specific requirements\n  }\n  \n  private clearTempVisuals(): void {\n    // Clear temporary visual feedback\n  }\n  \n  private generateId(): string {\n    return `measurement_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`;\n  }\n  \n  private notifyListeners(): void {\n    const measurements = this.getMeasurements();\n    for (const listener of this.listeners) {\n      listener(measurements);\n    }\n  }\n}